# Code Review Report
Course: C# Development SS 2023 (4 ECTS, 3 SWS)

Student ID: cc211010

BCC Group: B

Name: Ana Bonavides Aguilar

Your Project Topic: Dijkstra’s Algorithm

#

### A Short Summary about the Algorithm (What is the Background and the Motivation of having such an algorithm?): 
This algorithm was created by Edsger W.Dijkstra, to find the shortest path between two nodes in a weighted graph. It is important as in a lot of fields it is necessary to find the shortest path between two points. For example, between two cities. And, even though it is not the most performant, it lets you have, from a source, all the possible shortest paths you can have.

### Implementation Details

#### Implementation Logic Explanation:
I started by defining which was the easiest and most effective way of asking for the graph information to the User. For me and other of my collegues, writing the information as an Adjecency Matrix was the easiest way (as I wanted to let the user have a weighted directed graph.) Because of it, I defined my main user input as the 

#### Achievements:
(List down and explain what achievements you are proud of (e.g., features, techniques, etc.) in the project. Please explain in detail.)
1. I really like that you are able to generate multiple graphs, not only one, and get the paths of all of them. I achieved this by implementing a class's structure that lets the Algorithm have n amount of graphs. As a user, you are able to identify the different graphs outputs as the output file is a combination between the Graph's name (that must be defined at the beginning), and the emding "Output.txt".
2. I really like that the Ouput folder is automatically generated by checking whether it already exists or not. Even though it is a small piece of code, it makes a lot of difference on how organized the files look.
3. I liked presenting the project. I learned from the comments that I should not take for granted eveyrone knows all concepts I mention, and it was refreshing to get my classmate's opinions and thoughts on my solution (even after the presentation we discussed it.)

### Learned Knowledge from the Project
1. Something really specific that I learned was that array's size can be defined at runtime...It was surprising that I did not know, but also great having learned it.
2. I realized that the way I like the most to go about developing is first thinking of the way I want to input the data, and then, based on it, define which will be my structure to store it. I heard this once from my boyfriend and tried it for the project. I really liked it!
3. Sometimes we need to choose between having a "better" solution, to a solution that will be able to be mantained. There was some code that got really intertwined at some point, and I needed to make the choice of adding more lines of code to achieve it, or store some more variables. Even though these were not needed, it let me continue to work with the code without getting confused.


#### Major Challenges and Solutions:
(List down and explain the major challenges. Did you solve it? How? Please explain in detail.)
1. Keeping the code clean and understandable was a big challenge. There were some challenges I wanted to tackle, like outputing the data, where the places I was storing information made no sense duirng my first iteration of the code. For that one, for example, I ended up creating a function in my Algorithm class that returns the information I want to output as a string, that way my Main program does not need to handle printing.
2. Definitely working on the actual implementation of teh algorithm, mainly the exceptions and handling some edge cases, was a tough one. Because the output was only text (and I am way more of a visual person) I needed to rely on my debugging skills to see what was going on. One of these was breaking the main while loop after realizing that the remaining nodes could not be visited. I had to make use of a "undefined flag" (a "-1") to get int inm the case that my MinDistNode could not find any usable node. It was a pretty cool solution, if I may say, and mantaining a good idea of what the code was doing let me solve it.

#### Minor Challenges and Solutions:
(List down and explain the minor challenges. Did you solve it? How? Please explain in detail.)
1. Keeping the if-else code logic was hard at some points, I really needed to ask myself "which result do I want to achieve'and made it work before I tried to make it more efficient.
2. Mantaining good naming of variable was challenging, because the "best name"changed depending on how my current thought process of teh algorithm went.
3. Keeping the code free of old lines and of deprecated messages was important, to avoid being mislead by old comments and to make sure the final source code did not contain anything that was not used.

### Reflections on the Own Project:
(List down and explain what you could improve and add if you have more time.)
1. What I would make better is not having to add the number of nodes that a matrix has. Because the number can be determined by the amount of numbers that there are in one row of the inputed data, I could use that to automatically know how nodes there are. This could avoid mistakes by the user.
2. I would also add more input parsing and a way of handling errors, not only for those that would break the program, but specially for those that would make the output of the algorithm be wrong without the user noticing it (like a mistake in the adjacency matrix)
3. I would provide different ways of giving the input data. Even though I liked this one, there are probably cases where the user wants to, for exammple, give the input in form of nodes and list of edges. For a longer project it would be great to give more than one input possibility.

### Reflections on the Projects learned during the Presentation:
(List down and explain what you have learned from your colleague’s codes and what you should pay attention to when writing codes next time.)
1. Seeing Nana's solution of Dijkstra's algorithm made me think of the way I would have solved it with nodes and edges, and I think that would have also been interesting. Mainly seeing the differences in performance.
2. Even though I think Julia could have explained a little bit more her reasoning behind the implementation, it was nice seeing someone elses way of going about an algorithm solution.
3. I learned that having a pseudo-pseudo code written down can really help with understanding the algorithm. After seeing laura's presentation, I realized I could put more effort into communicating the reasoning behind the code, besides comments, as others might not be as acquinted to it as me.
4. Related to last point, I also learned t`1  hat I should probably explain all the concepts I use in presentations, without assuming that others already possess that knowledge.
